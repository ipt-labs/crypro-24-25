import random

# Алгоритм Евкліда для знаходження найбільшого спільного дільника (gcd)
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Оптимізована функція для обчислення функції Ейлера φ(n) для n = p * q
def phi_optimized(p, q):
    return (p - 1) * (q - 1)

# Зворотне значення за модулем
def mod_inverse(a, m):
    m0, x0, x1 = m, 0, 1
    while a > 1:
        q = a // m
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += m0
    return x1

# Функція для піднесення до степеня за модулем із використанням схеми Горнера
def horner_modular_exponentiation(x, a, m):
    y = 1  # Початкове значення
    k = a.bit_length()  # Довжина експоненти в бітах

    for i in range(k - 1, -1, -1):  # Проходимо біти зліва направо
        y = (y * y) % m  # Піднесення до квадрата (mod m)
        if (a >> i) & 1:  # Якщо i-й біт дорівнює 1
            y = (y * x) % m  # Додаємо внесок у результат

    return y


# Генерація e, яке задовольняє умови для RSA
# def generate_e(phi_n):
#     e = random.randint(2, phi_n - 1)
#     while gcd(e, phi_n) != 1:
#         e = random.randint(2, phi_n - 1)
#     return e

# Функція RSA_GEN
def RSA_GEN(p, q, e):
    n = p * q
    phi_n = phi_optimized(p, q)
    d = mod_inverse(e, phi_n)
    if (e * d) % phi_n == 1:
        print(f"Коректно: e * d = 1 mod φ(n) для e = {e}, d = {d}")
    else:
        print(f"Помилка: e * d != 1 mod φ(n) для e = {e}, d = {d}")
    return n, e, d

# Шифрування повідомлення
def Encrypt(m, e, n):
    return horner_modular_exponentiation(m, e, n)

# Розшифрування повідомлення
def Decrypt(c, d, n):
    return horner_modular_exponentiation(c, d, n)

# Створення цифрового підпису
def Sign(m, d, n):
    return horner_modular_exponentiation(m, d, n)

# Перевірка цифрового підпису
def Verify(s, e, n):
    return horner_modular_exponentiation(s, e, n)

# Функція для передачі ключа
def SendKey(k, d, n, e1, n1):
    # Генерація цифрового підпису для A
    s = Sign(k, d, n)
    print(f"Цифровий підпис для A: S = {s}")
    
    # Шифрування повідомлення та підпису для передачі абоненту B
    k1 = Encrypt(k, e1, n1)
    s1 = Encrypt(s, e1, n1)
    print(f"Абонент А формує повідомлення k1, s1 і відправляє його B \n k1 = {k1} \n S1 = {s1}")
    
    # Повернення зашифрованих значень
    return k1, s1

# Функція для отримання ключа та перевірки автентичності
def ReceiveKey(k1, s1, d1, n1, e, n):
    # Дешифрування повідомлення та підпису за допомогою секретного ключа B
    k = Decrypt(k1, d1, n1)
    s = Decrypt(s1, d1, n1)
    print(f"Абонент B за допомогою свого секретного ключа d1 знаходить (конфіденційність): \n k = {k} \n S = {s}")
    
    # Перевірка підпису A за допомогою відкритого ключа A
    k_verified = Verify(s, e, n)
    print(f"І за допомогою відкритого ключа e абонента А перевіряє підпис А (автентифікація): k = {k_verified}")
    
    return k_verified
    
# Задані прості числа
p = 36646164541686624240937833154972327964008617161515222144838114780214993351409
q = 31539962308096287988814609326825756936315439947047156766760061841746726548927
p1 = 73431616661604875049686928558414853172421655489331888049826565905174368641603
q1 = 82976583645640818895092178503362825123374069319439494124111219775406714256373
e = 65537

# Генерація ключів для A
n, e, d = RSA_GEN(p, q, e)
print(f"Для A: n = {n}, \ne = {e}, \nd = {d}\n")

# Генерація ключів для B
n1, e1, d1 = RSA_GEN(p1, q1, e)
print(f"Для B: n1 = {n1}, \ne1 = {e1}, \nd1 = {d1}\n")
print("\n" , "="*300, "\n")

# Створення відкритого повідомлення
M = random.randint(1, n - 1)
M1 = random.randint(1, n1 - 1)

print(f"Повідомлення для A: M = {M}")

# Шифрування повідомлення для A
C = Encrypt(M, e, n)
print(f"Зашифроване повідомлення для A: C = {C}")

# Розшифрування повідомлення для A
M_dec = Decrypt(C, d, n)
print(f"Розшифроване повідомлення для A: M = {M_dec}")

# Цифровий підпис для A
S = Sign(M, d, n)
print(f"Цифровий підпис для A: S = {S}")

# Перевірка цифрового підпису для A
M_verify = Verify(S, e, n)
print(f"Перевірка підпису для A: M = {M_verify}")

print(f"\nПовідомлення для B: M1 = {M1}")

# Шифрування повідомлення для B
C1 = Encrypt(M1, e1, n1)
print(f"Зашифроване повідомлення для B: C1 = {C1}")

# Розшифрування повідомлення для B
M1_dec = Decrypt(C1, d1, n1)
print(f"Розшифроване повідомлення для B: M1 = {M1_dec}")

# Цифровий підпис для B
S1 = Sign(M1, d1, n1)
print(f"Цифровий підпис для B: S1 = {S1}")

# Перевірка цифрового підпису для B
M1_verify = Verify(S1, e1, n1)
print(f"Перевірка підпису для B: M1 = {M1_verify}")

print("\n", "=" * 300, "\n")

# Приклад використання функцій
k = 1138871245103717467790293341541266222372696957810768120515208988767366165699249917157999604271883662770956240389270967991142452518801509339383355463954446
print(f"Повідомлення, k = {k}")

# Виклик функції SendKey
k1, s1 = SendKey(k, d, n, e1, n1)

print("\n", "-" * 300, "\n")

# Виклик функції ReceiveKey
k_verified = ReceiveKey(k1, s1, d1, n1, e, n)
